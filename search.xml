<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[psr-11]]></title>
    <url>%2F2017%2F11%2F07%2Fpsr16%2F</url>
    <content type="text"><![CDATA[PSR-11This document describes a common interface for dependency injection containerswiki-DI(denpendcy injection）维基百科依赖资料(DI是IOC的一种实现方式)yii2-Container深入了解Yii2 Container PSR-11描述了DI container的基本框架和定义.但是只依靠PSR-11文档是很难正确理解.我将结合wiki和yii2的Container来学习PSR-11. 概念依赖倒置原则（Dependence Inversion Principle, DIP）DIP是一种软件设计的指导思想。传统软件设计中，上层代码依赖于下层代码，当下层出现变动时，上层代码也要相应变化，维护成本较高。而DIP的核心思想是上层定义接口，下层实现这个接口，从而使得下层依赖于上层，降低耦合度，提高整个系统的弹性。这是一种经实践证明的有效策略。 控制反转（Inversion of Control, IoC）IoC就是DIP的一种具体思路，DIP只是一种理念、思想，而IoC是一种实现DIP的方法。IoC的核心是将类（上层）所依赖的单元（下层）的实例化过程交由第三方来实现。 依赖注入（Dependence Inversion, DI）DI是IoC的一种设计模式.DI的核心是把类所依赖的单元的实例化过程，放到类的外面去实现。 控制反转容器（IoC Container）当项目比较大时，依赖关系可能会很复杂。而IoC Container提供了动态地创建、注入依赖单元，映射依赖关系等功能，减少了许多代码量。 服务定位器（Service Locator）Service Locator是IoC的另一种实现方式，其核心是把所有可能用到的依赖单元交由Service Locator进行实例化和创建、配置，把类对依赖单元的依赖，转换成类对Service Locator的依赖。DI 与 Service Locator并不冲突，两者可以结合使用。 依赖注入在软件工程中，依赖注入是一种技术，一个对象提供另一个对象的依赖关系。依赖关系是可以使用的对象（服务）。注入是将依赖关系传递给将使用它的依赖对象（客户端）。该服务是客户状态的一部分。[1]把服务交给客户，而不是让客户去建立或者找到服务，这是这种模式的基本要求。 依赖注入设计模式解决了如下问题: 应用程序如何独立于其对象的创建 一个类如何独立于他所需要的对象是如何创建的 如何在单独的配置文件中指定创建对象的方式 应用程序如何支持不同的配置 依赖注入如何解决这些问题: 定义一个独立的(注入器)对象,创建并注入一个类需要的对象 一个类从一个注入器对象接受它所需要的对象,而不是直接创建对象 依赖注入涉及的四个角色: 提供服务的对象 依赖于它所使用的服务的客户端对象 一个定义如何使用服务的接口 注入器(构建服务并注入到客户端) UML: 三种类型的依赖注入: 构造函数注入: 依赖是通过类构造函数提供的 setter注入: 客户端公开了注入器用来注入依赖关系的setter方法 接口注入: 依赖关系提供了一个注入的方法,将依赖注入到传递给它的任何客户端.客户端必须实现一个接受依赖关系的setter方法 构造函数 注入:12345678910111213class Email&#123; public __construct(Service service) &#123; $this.service = service &#125;&#125;$service1 = new Service1;$service2 = new Service2;$email1 = new Email($service1);$email2 = new Email($service2); Setter 注入:12345678910class Eamil&#123; public setService(Service service) &#123; $this.service = service &#125;&#125;$service1 = new Service1;$email = new Email;$email-&gt;setService($service1); 接口 注入:123456789interface ServiceSetter&#123; pubic setService(Service service);&#125;class Client implements ServiceSetter&#123; pulic setService(Service service)&#125; PSR-11Psr-11(省略了exception接口)1234567namespace Psr\Container;interface ContainerInterface&#123; public function has($id); public function get($id);&#125; get:根据标识取回所期望的对象或者异常.has:是否有期望的对象目的:通过一个container获取所需要的对象和参数； 在阅读完PSR-11以后,脑子里所剩下的东西.感觉过于简单。所以有以下的行为,只在能够多的了解 DI Container。 Yii2 container实现这里只简要说明yii2的实现(只有返回object,省略很多细节).详情看原文123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162class Instance&#123; // 仅有的属性，用于保存类名、接口名或者别名 public $id; // 构造函数，仅将传入的ID赋值给 $id 属性 protected function __construct($id) &#123; &#125; // 静态方法创建一个Instance实例 public static function of($id) &#123; return new static($id); &#125;&#125;class Container&#123; private $_reflections = []; private $_params = []; private $_dependencies = []; public function get($class, $params=[], $config=[]) &#123; if(!isset($this-&gt;_definitions[$class])) &#123; return $this-&gt;build($class, $params, $config); &#125; // 注意这里创建了 $_definitions[$class] 数组的副本 $definition = $this-&gt;_definitions[$class]; if (is_array($definition)) &#123; $concrete = $definition['class']; unset($definition['class']); if ($concrete === $class) &#123; // 这是递归终止的重要条件 $object = $this-&gt;build($class, $params, $config); &#125; else &#123; // 这里实现了递归解析 $object = $this-&gt;get($concrete, $params, $config); &#125; &#125; else if(is_object($definition)) &#123; return $definition; &#125;else &#123; throw new InvalidConfigException("Unexpected object definition type: " . gettype($definition)); &#125; return object; &#125; public function set($class, $defintion = [], array $param = []) &#123; // 规范化 $definition 并写入 $_definitions[$class] $this-&gt;_definitions[$class] = $this-&gt;normalizeDefinition($class, $definition); // 将构造函数参数写入 $_params[$class] $this-&gt;_params[$class] = $params; return $this; &#125; public function build($class, $param, $config) &#123; list ($reflection, $dependencies) = $this-&gt;getDependencies($class); $dependencies = $this-&gt;resolveDependencies($dependencies, $reflection); return $reflection-&gt;newInstanceArgs($depencies); &#125; public function has($class) &#123; return isset($this-&gt;_definitions[$class]); &#125; //解析依赖信息 public function getDependencies($class) &#123; // 如果已经缓存了其依赖信息，直接返回缓存中的依赖信息 if (isset($this-&gt;_reflections[$class])) &#123; return [$this-&gt;_reflections[$class], $this-&gt;_dependencies[$class]]; &#125; $dependencies = []; // 使用PHP5 的反射机制来获取类的有关信息，主要就是为了获取依赖信息 $reflection = new ReflectionClass($class); // 通过类的构建函数的参数来了解这个类依赖于哪些单元 $constructor = $reflection-&gt;getConstructor(); if ($constructor !== null) &#123; foreach ($constructor-&gt;getParameters() as $param) &#123; if ($param-&gt;isDefaultValueAvailable()) &#123; // 构造函数如果有默认值，将默认值作为依赖。即然是默认值了， // 就肯定是简单类型了。 $dependencies[] = $param-&gt;getDefaultValue(); &#125; else &#123; $c = $param-&gt;getClass(); // 构造函数没有默认值，则为其创建一个引用。 // 就是前面提到的 Instance 类型。 $dependencies[] = Instance::of($c === null ? null : $c-&gt;getName()); &#125; &#125; &#125; // 将 ReflectionClass 对象缓存起来 $this-&gt;_reflections[$class] = $reflection; // 将依赖信息缓存起来 $this-&gt;_dependencies[$class] = $dependencies; return [$reflection, $dependencies]; &#125; public function resolveDependencies($depencies, $reflection = null) &#123; foreach ($dependencies as $index =&gt; $dependency) &#123; // 前面getDependencies() 函数往 $_dependencies[] 中 // 写入的是一个 Instance 数组 if ($dependency instanceof Instance) &#123; if ($dependency-&gt;id !== null) &#123; // 向容器索要所依赖的实例，递归调用 yii\di\Container::get() $dependencies[$index] = $this-&gt;get($dependency-&gt;id); &#125; elseif ($reflection !== null) &#123; $name = $reflection-&gt;getConstructor() -&gt;getParameters()[$index]-&gt;getName(); $class = $reflection-&gt;getName(); throw new InvalidConfigException( "Missing required parameter \"$name\" when instantiating \"$class\"."); &#125; &#125; &#125; return $dependencies; &#125;&#125;// 创建一个DI容器$container = new Container;// 为Connection指定一个数组作为依赖，当需要Connection的实例时，// 使用这个数组进行创建$container-&gt;set('yii\db\Connection', [ 'dsn' =&gt; '...',]);// 在需要使用接口 UserFinderInterface 时，采用UserFinder类实现$container-&gt;set('app\models\UserFinderInterface', [ 'class' =&gt; 'app\models\UserFinder',]);// 为UserLister定义一个别名$container-&gt;set('userLister', 'app\models\UserLister');// 获取这个UserList的实例$lister = $container-&gt;get('userLister'); set:接受依赖关系get:返回实例getDepencies:解析依赖信息[通过反射收集实例的依赖信息]resolveDependencies:实现依赖关系[通过递归实现依赖类的实例化]build:实现实例 通过set注入依赖关系,get取回所需的实例,实现了DI Container; ##Yii2 Service Locator Service Locator充当了一个运行时的链接器的角色，可以在运行时动态地修改一个类所要选用的服务， 而不必对类作任何的修改。 一个类可以在运行时，有针对性地增减、替换所要用到的服务，从而得到一定程度的优化。 实现服务提供方、服务使用方完全的解耦，便于独立测试和代码跨框架复用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134class ServiceLocator extends Component&#123; private $_components = []; private $_definitions = []; public funciton has($id, $checkInstance = false) &#123; return $checkInstance ? isset($this-&gt;__componets[$id]) : isset($this-&gt;_definitions['id']); &#125; public function get($id, $throwException = true) &#123; if (isset($this-&gt;_components[$id])) &#123; return $this-&gt;_components[$id]; &#125; // 如果还没有实例化好，那么再看看是不是已经定义好 if (isset($this-&gt;_definitions[$id])) &#123; $definition = $this-&gt;_definitions[$id]; // 如果定义是个对象，且不是Closure对象，那么直接将这个对象返回 if (is_object($definition) &amp;&amp; !$definition instanceof Closure) &#123; // 实例化后，保存进 $_components 数组中，以后就可以直接引用了 return $this-&gt;_components[$id] = $definition; // 是个数组或者PHP callable，调用 Yii::createObject()来创建一个实例 封装了调用container 的方法 &#125; else &#123; // 实例化后，保存进 $_components 数组中，以后就可以直接引用了 return $this-&gt;_components[$id] = Yii::createObject($definition); &#125; &#125; elseif ($throwException) &#123; throw new InvalidConfigException("Unknown component ID: $id"); // 就给你找到想要的组件或服务呀，给你个 null 吧。 // 表示Service Locator中没有这个ID的服务或组件。 &#125; else &#123; return null; &#125; &#125; public function set($id, $definition) &#123; // 当定义为 null 时，表示要从Service Locator中删除一个服务或组件 if ($definition === null) &#123; unset($this-&gt;_components[$id], $this-&gt;_definitions[$id]); return; &#125; // 确保服务或组件ID的唯一性 unset($this-&gt;_components[$id]); // 定义如果是个对象或PHP callable，或类名，直接作为定义保存 // 留意这里 is_callable的第二个参数为true，所以，类名也可以。 if (is_object($definition) || is_callable($definition, true)) &#123; // 定义的过程，只是写入了 $_definitions 数组 $this-&gt;_definitions[$id] = $definition; // 定义如果是个数组，要确保数组中具有 class 元素 &#125; elseif (is_array($definition)) &#123; if (isset($definition['class'])) &#123; // 定义的过程，只是写入了 $_definitions 数组 $this-&gt;_definitions[$id] = $definition; &#125; else &#123; throw new InvalidConfigException("The configuration for the \"$id\" component must contain a \"class\" element."); &#125; &#125; else &#123; throw new InvalidConfigException( "Unexpected configuration type for the \"$id\" component: " . gettype($definition)); &#125; &#125;&#125;// static::$container就是上面说的引用了DI容器的静态变量public static function createObject($type, array $params = [])&#123; // 字符串，代表一个类名、接口名、别名。 if (is_string($type)) &#123; return static::$container-&gt;get($type, $params); // 是个数组，代表配置数组，必须含有 class 元素。 &#125; elseif (is_array($type) &amp;&amp; isset($type['class'])) &#123; $class = $type['class']; unset($type['class']); // 调用DI容器的get() 来获取、创建实例 return static::$container-&gt;get($class, $params, $type); // 是个PHP callable则调用其返回一个具体实例。 &#125; elseif (is_callable($type, true)) &#123; // 是个PHP callable，那就调用它，并将其返回值作为服务或组件的实例返回 return call_user_func($type, $params); // 是个数组但没有 class 元素，抛出异常 &#125; elseif (is_array($type)) &#123; throw new InvalidConfigException( 'Object configuration must be an array containing a "class" element.'); // 其他情况，抛出异常 &#125; else &#123; throw new InvalidConfigException( "Unsupported configuration type: " . gettype($type)); &#125;&#125;Yii::$app-&gt;set('db', [ 'class' =&gt; 'yii\db\Connection', 'dsn' =&gt; 'mysql:host=db.digpage.com;dbname=digpage.com', 'username' =&gt; 'www.digpage.com', 'password' =&gt; 'www.digapge.com', 'charset' =&gt; 'utf8',]);Yii::$app-&gt;set('cache', [ 'class' =&gt; 'yii\caching\MemCache', 'servers' =&gt; [ [ 'host' =&gt; 'cache1.digpage.com', 'port' =&gt; 11211, 'weight' =&gt; 60, ], [ 'host' =&gt; 'cache2.digpage.com', 'port' =&gt; 11211, 'weight' =&gt; 40, ], ],]); 从上面的代码中，可以看到Service Locator维护了两个数组, $_components 和$_definitions 。这两个数组均是以服务或组件的ID为键的数组。其中， $_components用于缓存存Service Locator中的组件或服务的实例。 Service Locator 为其提供了getter和setter。使其成为一个可读写的属性。 $_definitions 用于保存这些组件或服务的定义。 servicerLocater 通过调用 createObject 函数获取 DI Container 的返回的实例,通过这样的方式完成了 DI容器和 Service Locater 的配合使用 总结Service Locator 和 DI Container 都可以用来降低代码耦合程度，提高项目的可维护性。yii2 为我们提供了两者配合使用的例子。]]></content>
      <categories>
        <category>psr</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>psr</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[psr6]]></title>
    <url>%2F2017%2F10%2F31%2Fpsr6%2F</url>
    <content type="text"><![CDATA[PHP psr6The goal of this PSR is to allow developers to create cache-aware libraries that can be integrated into existing frameworks and systems without the need for custom development. PSR6定义了Cache的最基本的三个组成部分,CachePool,CacheItem,CacheException.是创建一套通用的接口规范,能够让开发人员整合到现有框架和系统，而不需要去开发框架专属的适配器类。 Definition: Calling Library -调用者，使用缓存服务的类库,不关心具体实现 Implementing Library -具体实现，提供CacheItem,CachePool调用接口,支持以下功能 TTl(time to live) -精确到秒 Expiration -准确的过期时间点,一般为 CacheStartTime + TTL Key -唯一键 Hit -一个缓存的命中,调用类应该先验证isHit,命中后get数据 Miss -使用键获取缓存时,得到过期,数据错误的结果,按MISS 对待 Deferred -一个延迟的缓存 CacheItem:必须 支持所有的可序列化的 PHP 数据类型: Strings Integers Floats Bollean NUll Arrays Object(serialize,unserialize) 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace Psr\Cache;interface CacheItemInterface&#123; public function getKey() &#123; &#125; public function get() &#123; &#125; public function isHit() &#123; &#125; public function set($value) &#123; &#125; public function expiresAt($expiration) &#123; &#125; public function expiresAfter($time) &#123; &#125;&#125; CachePool123456789101112131415161718&lt;?phpnamespace Psr\Cache;interface CacheItemPoolInterface&#123; public function getItem($key)&#123;&#125; public function getItems(array $keys = array())&#123;&#125; public function hasItem($key)&#123;&#125; public function clear()&#123;&#125; public function deleteItem($key)&#123;&#125; public function deleteItems(array $keys) &#123;&#125;&#125; CacheException123456789101112&lt;?phpnamespace Psr\Cache;/** * Exception interface for all exceptions thrown by an Implementing Library */interface CacheException&#123;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>psr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[psr4]]></title>
    <url>%2F2017%2F10%2F30%2Fpsr4%2F</url>
    <content type="text"><![CDATA[PHP PSR-4This PSR describes a specification for autoloading classes from file paths. It is fully interoperable, and can be used in addition to any other autoloading specification, including PSR-0. This PSR also describes where to place files that will be autoloaded according to the specification. spl_autoload_register —- 将函数注册到SPL __autoload函数队列中 Closure Example12345678910111213141516171819202122232425262728293031&lt;?php/** * An example of a project-specific implementation. * * After registering this autoload function with SPL, the following line * would cause the function to attempt to load the \Foo\Bar\Baz\Qux class * from /path/to/project/src/Baz/Qux.php: * * new \Foo\Bar\Baz\Qux; * * @param string $class The fully-qualified class name. * @return void */ spl_autoload_register(function ($class) &#123; $prefix = '\Vendor'; $baseDir = __DIR__.'/'; $len = strlen($prefix); if (! strncmp($prefix, $class, $len)) &#123; return ; &#125; $file = $baseDir .str_replace('\\', '/', $class).'.php'; if (file_exists($file)) &#123; require $file; // require_once($file); &#125; &#125;); $a = new \Vendor\Food\Food(); class Examplespl_autoload_register(array(class,’function’)); 注册类方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpclass ClassLoader&#123; public $prefixesMap = array(); public function register () &#123; spl_autoload_register($this, 'loadClass'); &#125; public function addNamespace ($prefix, $base_dir, $prepend = false) &#123; $prefix = trim($prefix, '\\').'\\'; $base_dir = rtrim($base_dir, DIRECTORY_SEPARATOR).'/'; // initialize the namespace prefix array if (isset($this-&gt;prefixesMap[$prefix]) === false) &#123; $this-&gt;prefixesMap[$prefix] = array(); &#125; // retain the base directory for the namespace prefix if ($prepend) &#123; array_unshift($this-&gt;prefixesMap[$prefix], $base_dir); &#125; else &#123; array_push($this-&gt;prefixesMap[$prefix], $base_dir); &#125; &#125; public function loadClass ($class) &#123; $prefix = $class; while ( false !== $pos = strrpos($prefix, '\\')) &#123; $prefix = substr($class, 0, $pos + 1); $relative_class = substr($class, $pos + 1); $mapped_file = $this-&gt;loadMapFile($prefix, $relative_class); if ($mapped_file) &#123; return $mapped_file; &#125; $prefix = rtrim($prefix, '\\'); &#125; return false; &#125; protected function loadMapFile ($prefix, $relative_class) &#123; if (isset($this-&gt;prefixesMap[$prefix]) === false) &#123; return false; &#125; foreach ($this-&gt;prefixesMap[$prefix] as $base_dir) &#123; $file = $base_dir.$relative_class.'.php'; if ($this-&gt;include($file)) &#123; return $file; &#125; &#125; return ; &#125; protected function include ($file) &#123; if (file_exists($file)) &#123; require $file; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>psr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[psr-3]]></title>
    <url>%2F2017%2F10%2F16%2F2017-10-16%2F</url>
    <content type="text"><![CDATA[PHP PSR-3This document describes a common interface for logging libraries. psr3制定并提供了日志类库的通用接口规范.实际中我们需要进行区扩展.但仍需遵循规范.NsAbstractLogger 实现Psr\Log\LoggerInterface,并且应该在这里实现所需的扩展.子类具体实现功能。 12345678910111213namepace Ns\Logger;use Psr\Log;abstract class NsAbstractLogger implements Psr\Log\LoggerInterface&#123; //implement interface and expand &#125; class NsLogger extend NsAbstractLogger&#123; //&#125;]]></content>
      <categories>
        <category>psr</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>psr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[psr1,psr2]]></title>
    <url>%2F2016%2F10%2F18%2F20161025%2F</url>
    <content type="text"><![CDATA[PHP-FIGThis section of the standard comprises what should be considered the standard coding elements that are required to ensure a high level of technical interoperability between shared PHP code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?phpnamespace Vendor\Package;use Footer;use Hello as Hel;use OtherVender\OtherPackage\BazClass;use Test;/*** Code Style Example* @auth sonw* @date 2016-10-18*/class CodeStyle extends Footer implements HelloInterface, Test\TestInterface, Test\NoneInterface&#123; public function sampleFunction($a, $test, $m, $b = 'ss') &#123; if ($a == $b) &#123; hel(); &#125; elseif ($a &gt; $b) &#123; echo 'da'; &#125; else &#123; echo 'kk'; &#125; &#125; public function tryCatch() &#123; //catch error try &#123; throw new Exception('error'); &#125; catch (FirstException $e) &#123; &#125; catch (Exception $e) &#123; &#125; &#125; final public static function bar($bar) &#123; switch ($bar) &#123; case 0: echo 'Fisrt case'; break; case 1: echo 'Second case'; case 2: case 3: echo 'This a one '; break; default: # code... echo 'defalt'; break; &#125; &#125; public function cycle($expr) &#123; do &#123; &#125; while ( $expr); &#125; public function loop($item) &#123; foreach (item as $key =&gt; $value) &#123; &#125; &#125;&#125;$codeStyle = new CodeStyle();$codeStyle-&gt;sampleFunction( $a, $b, $c,);//closures$var1 = new CodeStyle();$var2 =3;$closureWithArg = function ($arg1, $arg2) use($var1, $var2) &#123;&#125;?&gt;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>psr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客第一篇]]></title>
    <url>%2F2016%2F10%2F17%2F2016-10-18%2F</url>
    <content type="text"><![CDATA[目前写博客主要目的是： 1.梳理和沉淀自己的技术2.练习写博客]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
</search>
